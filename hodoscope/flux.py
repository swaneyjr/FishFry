#!/usr/bin/env python

import os
import sys

import numpy as np
import matplotlib.pyplot as plt

# temporary hack to add pixelstats modules to path
fishfry_dir = os.path.dirname(os.path.dirname(__file__))
sys.path.insert(0, os.path.join(fishfry_dir, 'monte_carlo'))

from plot_coincidences import add_voltage
from mc_thresh import load
from acceptance import monte_carlo


def mc_acceptance(path_thresh, gap, n=2):
    
    n_sim = 10000000

    # LYSO dimensions
    x = np.array([14., 14.])
    y = np.array([16., 16.])
    z = np.array([0., gap], dtype=float)

    border = 3 * np.tan(75*np.pi/180)

    hits = monte_carlo(n_sim, 
            -x/2, x/2, 
            -y/2, y/2,
            z-3, z+3,
            0, border, path_thresh, n_ang=n)

    n_hodo = np.logical_and(hits[0], hits[1]).sum()
    area = (x[0] + 2*border) * (y[0] + 2*border) * 1e-6 # in m^2
    return area * n_hodo / n_sim, 0



if __name__ == '__main__':
    from argparse import ArgumentParser

    parser = ArgumentParser()
    parser.add_argument('--triggers', required=True, nargs='+', help='Hodoscope .npz files')
    parser.add_argument('--gaps', required=True, nargs='+', help='Center-to-center LYSO gaps for hodoscope files')
    parser.add_argument('--labels', required=True, nargs='+', help='Labels for each trigger file')
    parser.add_argument('--combinations', required=True, nargs='+', help='One of (ab, ac, bc) for each file')
    parser.add_argument('--path_fit', required=True, help='.npz file with linear fit generated by mc_thresh.py')

    args = parser.parse_args()

    lengths = np.array([len(args.triggers), 
        len(args.gaps), 
        len(args.labels), 
        len(args.combinations)])
    
    if not np.all(lengths == lengths[0]):
        raise ValueError('Unequal number of arguments given')

    fit = np.load(args.path_fit)
    a, b = fit['coeffs']
 
    plt.figure(figsize=(6,4.5))
    ax = plt.gca()
    
    # mark accepted range
    ax.fill_between([0, 256], np.pi/2 * 72, np.pi/2 * 91, fc='lightskyblue', alpha=0.3, label='Accepted muon flux')

    # add trigger data
    thresh_min = 256
    thresh_max = 0
    for fname, gap, label, c in zip(args.triggers, args.gaps, args.labels, args.combinations):
        print(fname)
        f = np.load(fname)

        thresh, rate, rate_err = load(f, c)
        path_thresh = a + b*(thresh-52)
        thresh_min = min(thresh_min, thresh.min())
        thresh_max = max(thresh_max, thresh.max())

        acceptance, acc_err = np.array([mc_acceptance(path, gap) for path in path_thresh]).T
        flux = rate / acceptance * 1e3
        flux_err = rate_err / acceptance * 1e3
        for i in range(path_thresh.size):
            print('{} {:.2f} {:.2f} {:.2f}'.format(thresh[i], path_thresh[i], flux[i], flux_err[i]))

        ax.errorbar(thresh, flux, yerr=flux_err, marker='.', capsize=3, capthick=1, ls='', label=label)

        f.close()
        print()

    ax.set_xlim(thresh_min-1, thresh_max+1)

    ax.set_title('Estimated vertical flux')
    ax.set_xlabel('PWM threshold')
    ax.set_ylabel('$J_1 (Hz/m^2)$')

    plt.legend()

    add_voltage(ax)
    plt.tight_layout()

    plt.show()
