#!/usr/bin/env python3

import os

import ROOT as r
import numpy as np
import matplotlib.pyplot as plt

# temporary hack to add pixelstats modules to path
fishfry_dir = os.path.dirname(os.path.dirname(__file__))
sys.path.insert(0, os.path.join(fishfry_dir, 'pixelstats'))
from geometry import load_res
from lens_shading import load_weights
from electrons import load_electrons


COUNTS = {
        'max': 1,
        'sum5': 5,
        'sum9': 9,
        'sum21': 21,
        }

if __name__ == '__main__':
    from argparse import ArgumentParser
    parser = ArgumentParser(description='')
    parser.add_argument('pfile', nargs='+', help='ROOT file generated by mark_triggered.py')
    parser.add_argument('--calib', default='calib', help='path to calibration directory')
    parser.add_argument('--thresh', type=int, default=0, help='Additional threshold')
    parser.add_argument('--log', action='store_true', help='Display a logscale for y')
    parser.add_argument('--bin_sz', type=int, default=16, help='Bin width for plots')
    parser.add_argument('--stat', choices=list(COUNTS.keys()), default='max', help='Statistic to measure')
    parser.add_argument('--sat', type=int, default=1023)
    args = parser.parse_args() 
     
    # first load calibration data
    try:
        f_acc = np.load(os.path.join(args.calib, 'acceptance.npz'))
        
        # P(hodoscope | phone)
        p_hgp = f_acc['p_hgp_AB']
        p_hgp_err = f_acc['p_hgp_err_AB']
        
        # P(phone | hodoscope)
        p_pgh = f_acc['p_pgh_AB']
        p_pgh_err = f_acc['p_pgh_err_AB']

        # in Hz
        expected_rate = f_acc['hodo_rate_AB']

        f_acc.close()
    except:
        print('ERROR: Acceptance not found. Try running "acceptance.py" first')
        exit(1)

    sat_min = 1023
    gmin = 0
    blk_lvl = 0
    try:
        wgt = load_weights(args.calib)
        sat_min = int(sat_min * wgt.min())
    except FileNotFoundError:
        print('Weights not found.  Using equal weights.')

    try:
        gmin, blk_lvl, dark_noise = load_electrons(args.calib)
    except FileNotFoundError:
        print('Could not find gain data.  Run pixelstats/electrons.py first')

    sat_min = min(args.sat, sat_min*COUNTS[args.stat])

    # now look through ROOT files

    # in order to avoid artificial caps, we restrict the range
    # to the minimum weighted saturation value
    
    bins = np.arange(0, 1025*COUNTS[args.stat], args.bin_sz)
    bin_min_all = 0
    bin_max_all = (sat_min+1)//args.bin_sz + 1
    cdf_vals = []
    cdf_errs = []

    for pf in args.pfile:
        print(pf)
        tag = []
        tot = []

        pfile = r.TFile(pf)
        ptree = pfile.Get('triggers')
        ntree = pfile.Get('nontriggers')
        btree = pfile.Get('blocks_AB')

        uinfo = btree.GetUserInfo()
        tolerance = n_hodo = t_tot = t_frame = None

        for param in uinfo:
            if param.GetName() == 'tolerance':
                tolerance =  param.GetVal()
            if param.GetName() == 'n_hodo':
                n_hodo = param.GetVal()
            if param.GetName() == 't_tot':
                t_tot = param.GetVal()

        if not tolerance or not n_hodo or not t_tot:
            print("ERROR: Metadata not found")
            exit(1)
        
        vmin = args.sat # this could probably just be saved from thresholds  

        # find ratio of triggered / total
        for evt in ptree:
            cmax = getattr(evt, args.stat)
            vmin = min(vmin, cmax)
            if cmax > args.thresh:
                tot.append(min(cmax, args.sat))
                if evt.tag_AB:
                    tag.append(min(cmax, args.sat))
        
        print("Triggered: {} / {}".format(len(tag), len(tot)))

        hodo_rate = n_hodo / t_tot * 1e3 # in Hz
        hodo_rate_err = np.sqrt(n_hodo) / t_tot * 1e3
        hodo_factor = np.exp(hodo_rate * 1e-3 * tolerance)
        
        print(u'observed rate: {:.3f} \u00B1 {:.3f} mHz'.format(hodo_rate * 1e3, hodo_rate_err * 1e3))
        print('expected rate: {:.3f} mHz'.format(expected_rate * 1e3))
 
        tag_hist, _ = np.histogram(tag, bins)
        tot_hist, _ = np.histogram(tot, bins)
 
        n  = np.cumsum(tot_hist[::-1]).astype(float)[::-1]
        nt = np.cumsum(tag_hist[::-1]).astype(float)[::-1]
        nnt = n - nt

        # use poisson statistics to estimate total number of hits
        # from triggered frames

        ntot = ptree.GetEntries() + ntree.GetEntries()
        nnttot = ntot - ntree.GetEntries('tag') - ntree.GetEntries('tag')
        
        N = -ntot * np.log(1-n/ntot)
        Nnt = -nnttot * np.log(1-nnt/nnttot)

        print('max trig rate: {:.2f}'.format(n[0] / ntot))

        # calculate and plot signal-to-noise ratio 

        cdf = (N - Nnt*hodo_factor) / n_hodo / p_pgh
        cdf_var = 0.01 * cdf**2 # FIXME

        cdf_vals.append(cdf)
        cdf_errs.append(np.sqrt(cdf_var))

        frac = cdf * n_hodo / N
        frac_var = 0.01 * frac**2

        snr = (1/frac-1)**-1
        snr_err = np.sqrt(frac_var)/(1-frac)**2

        vmin = max(vmin, args.thresh+1)
        bin_min = vmin // args.bin_sz
        bin_min_all = max(bin_min, bin_min_all)

        plt.figure(figsize=(6.4, 5.6)) 
        ax = plt.gca()
        ax.plot(bins[:-1][bin_min:bin_max_all], snr[bin_min:bin_max_all], 'r-')
        ax.fill_between(bins[:-1][bin_min:bin_max_all], (snr-snr_err)[bin_min:bin_max_all], (snr+snr_err)[bin_min:bin_max_all], color='red', alpha=0.2)

        if args.log:
            ax.semilogy()
        ax.set_xlabel('Calibrated ADC counts')
        ax.set_ylabel('signal / noise')
        ax.set_title('Integrated signal-to-noise ratio by max values')
        
        if gmin:
            ax2 = ax.twiny()
            ax2.set_xlim(*((np.array(ax.get_xlim()) - blk_lvl*COUNTS[args.stat]) / gmin))
            ax2.set_xlabel('Electrons')
            ax2.xaxis.set_ticks_position('bottom')
            ax2.xaxis.set_label_position('bottom')
            ax2.spines['bottom'].set_position(('outward', 36))

        plt.tight_layout() 
        
        print()

    cdf_combined = np.average(cdf_vals, axis=0, weights=1/np.square(cdf_errs))
    cdf_err_combined = 1/np.sqrt(np.sum(1/np.square(cdf_errs), axis=0))

    eff = cdf_combined[0]
    eff_err = cdf_err_combined[0]

    print(u'eff = {0:.4f} \u00B1 {1:.4f}'.format(eff, eff_err))
  
    plt.figure(figsize=(6.4, 5.6))
    ax = plt.gca()
    ax.plot(bins[:-1][bin_min:bin_max_all], cdf_combined[bin_min:bin_max_all], 'b-')
    ax.fill_between(bins[:-1][bin_min:bin_max_all], (cdf_combined-cdf_err_combined)[bin_min:bin_max_all], (cdf_combined+cdf_err_combined)[bin_min:bin_max_all], alpha=0.2)
    if args.log:
        ax.semilogy()
    ax.set_xlabel('Calibrated ADC counts')
    ax.set_ylabel('Probability')
    ax.set_title('Hit cdf by max values')

    if gmin:
        ax2 = ax.twiny()
        ax2.set_xlim(*(np.array(ax.get_xlim()) / gmin))
        ax2.set_xlabel('Electrons')
        ax2.xaxis.set_ticks_position('bottom')
        ax2.xaxis.set_label_position('bottom')
        ax2.spines['bottom'].set_position(('outward', 36))

    plt.tight_layout()

    plt.show()
